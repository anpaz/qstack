# Designing a Software Stack for Quantum Programs with Error Correction

Quantum processors differ fundamentally from classical computers. They leverage particles governed by quantum mechanics to perform computations using principles like superposition, entanglement, and interference. These properties allow quantum processors to perform certain tasks far more efficiently than classical computers. However, this efficiency comes at a cost: quantum computations are prone to extremely high error rates, which make long-running computations infeasible.

Error correction techniques, analogous to those used in long-distance communication, can mitigate this problem. The objective is to enable long-running quantum calculations by transparently integrating an error correction layer that reduces the error rate sufficiently to avoid computational failures. It is not that errors are completely removed, just mitigated enough to be able to confirm the result.

# Key Challenges:

1. **Classical Computation in Error Correction:**
   Error correction inherently involves **classical computation** (ref) â€”it requires real-time measurements and corrections based on classical logic. Designing a software stack that transparently incorporates this quantum error correction (qec) layer without introducing a fully hybrid language is a significant challenge. The stack must bridge the gap between quantum and classical processing seamlessly.

2. **Hardware and Code Dependence:**
   Quantum processors typically offer a small, hardware-specific set of universal instructions from which all other operations can be derived. These instruction sets vary across hardware platforms, reflecting differences in the underlying quantum technologies. Similarly, quantum error correction codes define their own universal sets of instructions, which differ between codes. This diversity complicates the development of a universal software stack.

# The `qstack` approach:

With `qstack`, we propose a generic mechanism to define a layer of quantum compilation and evaluation. `qstack` introduces clear boundaries to support two key types of composition:

- **Horizontal Composition:** Enables the composition of quantum instructions, even when implemented using fault-tolerant circuits with real-time error correction. Each quantum instruction consists of a computation graph generated by one or more layers from encoding and decoding quantum instructions.

- **Vertical Composition:** Allows layering to build concatenated error correction codes and decompositions to connect different layers.

qstack is designed to be **platform-agnostic** and **qec code-agnostic**, providing flexibility to adapt to diverse hardware platforms and error correction strategies. This design ensures the stack can support scalable quantum computations while remaining transparent to the user.

# Ideas

- Pure quantum language.
- Compilers can focus on quantum elements
- Clear boundaries of execution steps.

# Programs and Kernels

A quantum program is comprised of a list of kernels. A kernel represents a unit of computation consisting of:

```
program       :== kernels
kernels       :== kernel | kernels
kernel        :== target instructions
instructions  :== *None*
                | instruction
                | instruction instructions
                | kernel
instruction :== op targets
op          :== *id*
target      :== *id* | None
```

The simplest kernel that always returns the value `0` would be:

```
allocate q1:
measure
```

A kernel with a `flip` instruction would always return `1`:

```
allocate q1:
  flip q1
measure
```

# Kernel Semantics

Kernels follow classic quantum programs semantics.

A kernel's `allocate` initializes a single qubit, represented with a quantum state. This state is a 2-dimensional vector indicating the amplitude probabilities for measuring `0` or `1`. The qubit is always initialized in the state `[1, 0]`, corresponding to a 100% probability of measuring `0`.

Instructions inside a kernel modify the state by applying a unitary matrix. These operations transform the quantum state while preserving the total probability.

A kernel `measure` deallocates the associated qubit and returns either `0` or `1`, based on the respective probabilities defined by the state amplitudes.

A kernel can embed other kernels. Each time a qubit is allocated, the state size doubles, representing the probability of measuring the tensor product of the existing space with `0` and `1`. Other qubits remains in scope, allowing operations to be applied across all allocated qubits.

```
allocate q1:
  allocate q2:
  measure
measure
```

Instructions are applied to the entire state. If an instruction specifies a single qubit, it is understood as the Kronecker product of the one-qubit operation with the Identity operator applied to the remaining qubits. This ensures the operation affects only the specified qubit while leaving the rest of the computational state unchanged.

A `measure` collapses the state of the entire system. The state is projected onto one of two subspaces corresponding to the outcome (`0` or `1`) of the last computational space added to the system. The outcome depends on the state, with probabilities determined by the amplitudes of the basis states. The resulting state is renormalized to ensure the total probability remains 1, modifying the amplitudes of all basis states in the system accordingly.

Measurements are collected at runtime and stored in a FILO stack. The outcome of the program are the measurements in the stack.

A simple program that prepares and measures a bell-state could be represented as:

```
allocate q1:
  allocate q2:
    mix q1
    entangle q1 q2
  measure
measure
```

It is a common pattern to initialize and measure together multiple computations spaces, so we provide syntactic sugar for this. This is an equivalent bell-state preparation:

```
allocate q1 q2:
  mix q1
  entangle q1 q2
measure
```

# Hybrid kernels

Programs can incorporate classical computation after a kernel's measurement. This enhances our grammar with:

```
kernel        :== allocate target: compute measure >> classical_instruction
```

Classical instructions are invoked by consuming measurements from the measurement stack using the `>>` operator. The `>>` operator pops measurements from the stack and pass them to a classical instruction for execution. Once popped the measurement is not available for consumption anymore.

There are two types of classical instructions:

- continuations: return a new kernel, which is immediately evaluated.
- decoders: return a new measurement, which is pushed into the stack.

Notice that in neither case the classical instruction has the ability to modify the quantum state. All communication between the QPU and the CPU happen via measurements in the stack.

## Continuations

A continuation is a classical method that given a list measurements returns a new kernel. It enables different execution paths based on measurement outcomes.

Take for example the code for the Teleport protocol:

```
allocate target:
  allocate source shared:
    # prepare source in some random state
    random x

    # entangle shared and target
    h shared
    cx shared target

    # deentangle shared and source
    cx source shared
    h source
  measure
  >> teleport.fix(target)
measure
```

`teleport.fix` is a classical function defined in the `teleport` layer. A continuation consumes a fixed number of measurements from the stack and produces a new kernel. In this context, `fix` could be defined in Python as:

```
def fix(target, m0, m1):
    instructions = []
    if m1 == 1:
        instructions.append(Instruction('z', target))
    if m0 == 1:
        instructions.append(Instruction('x', target))
    return instructions
```

At runtime, if the outcome of the measurements is (0,1) `fix` returns:

```
z target
```

however, if the outcome is (1,1) `fix` returns:

```
z target
x target
```

The returned kernel is immediately evaluated before the next kernel starts.

### Loops

Notice a continuation can return another kernel that calls itself, enabling loops. For example, given this program:

```
allocate a:
measure
>> sample.loop
```

and a `loop` function like:

```python
def loop(m0):
  if m0 == 0:
    return Allocate('a', Instruction('h', 'a')).Continue(loop)
  else:
    return None
```

Notice how the program will keep running until the measurement of the qubit returns 1.

## Decoders

A decoder is a classical method that, given a list of measurements, returns a new measurement.

Take for example a simple majority bit vote encoding:

```
allocate q1 q2 q3:
measure
>> majority.vote
```

`majority.vote` is a classical function defined in the `majority` layer. Similar to a `continuation`, a decoder consumes measurements from the stack but produces a new outcome. In this context, `vote` would be defined as:

```python
def vote(m1, m2, m2):
    if sum([m1, m2, m3]) > 2
        return 1
    else:
        return 0
```

`>>` consumes 3 outcomes from the stack and pass them to `vote`. `vote` returns a single value `0` which is pushed into the stack, which is the only item left in the stack when the program completes, as such, the outcome of the program would then be just `0`.

The stack makes it possible to chain decoders. This is how majoriy vote would work with 3 blocks of 3 qubits:

```
allocate q1 q2 q3:
  allocate q3 q4 q5:
  measure >> majority.vote
  allocate q3 q4 q5:
  measure >> majority.vote
measure >> majority.vote
>> majority.vote
```

The outcome of this program would still be just `0`.

# Layers, Compilers & Stacks

A **layer** defines an **instruction set** available to a program, including both quantum and classical instructions.

A **compiler** transforms a program from one layer to another. It converts quantum instructions while preserving their semantics and retains classical instruction invocations with the same parameters. It may add new classical instructions as needed.

A **stack** is an ordered list of layers and compilers, where the top and bottom elements are always layers, and a compiler exists between each pair of layers.

A program is associated with a stack. All quantum instructions must belong to the bottom layer, while classical instructions can originate from any layer and are always prefixed by the layer they belong to. The actual stack is specified via a `@stack` attribute:

```
@stack: cliffords

allocate: q1 q2
  h q1
  cx q1 q2
measure
```

# Executing programs

At runtime, quantum instructions in the kernel are evaluated by a QPU capable of processing the instructions of the bottom layer.

Classical instructions are evaluated as follows:

1. **Continuations**: Invoked to produce a new kernel, which is compiled in real time by the stack into the lowest-level layer. Once compiled, the resulting kernel is evaluated by the QPU.
2. **Decoders**: Invoked to generate a new measurement, which is pushed onto the measurement stack.

---

# old stuff...

### Error correction layer

An error correction layer accepts the list
of encoded instruction supported by an error correction code, and generates gadgets
implemented in terms of an output instruction set, typically the set of clifford
instructions. For example, the outcome of evaluating program (1)
with an error correction layer based on the repetition code would be similar to:

```
allocate: q0.0 q0.1 q0.2 q1.0 q1.1 q1.2
  allocate: a0 a1
    cx q0.0 a0
    cx q0.1 a1
    cx q0.1 a0
    cx q0.2 a1
  measure
  ---
  allocate: a0 a1
    cx q1.0 a0
    cx q1.1 a1
    cx q1.1 a0
    cx q1.2 a1
  measure
  ---
  h q0.0
  h q0.1
  h q0.2
  ---
  ...
measure
```

### Noise layer

A noise layer emulates noise on a device by adding random instructions based on a noise model. For example, a pauli-noise layer will add random Pauli instructions to a program with some probability.

### Physical layer

A physical layer is used for executing instructions on an emulator or QPU. A physical layer accepts
instructions from an input instruction set and generates empty gadgets, therefore it has an empty output instruction set.

In a physical layer, each block corresponds to an individual qubit.

> Physical layers can be generated from any other layer by taking a layer's output instruction set and building the corresponding state-vector emulator that accepts the same list of instructions and applies their corresponding `action`.

## Layer design

A layer implements the following methods:

- **allocate(block_ids)**: assign a block to the given ids
- **measure(block_ids)**: measures and unassigns the corresponding blocks ids, returns the measured values.
- **eval(instructions)**: evaluates the given instructions. The outcome of eval is is a list of gadgets.

# Gadgets

A gadget represents a unit of hybrid execution in a quantum processor. It is comprised of:

1. **kernel**: a kernel to be evaluated by a layer
2. **continuation**: an optional method that given the list of outcomes from the kernel's measurements, returns a new gadget.

# Stack

Instructions are evaluated in the context of a quantum stack. A stack is comprised of an ordered list of layers.

A stack is said to be valid if for all layers in the stack, each instruction in the ouput instruction set is an instruction of the input instrction set of the next layer in the stack.

<!-- prettier-ignore -->
$L_{n}.\text{O} \subset L_{n+1}.\text{I}$

# Encoding quantum programs

Encoding is the process of evaluating a quantum program through the layers of a quantum stack, and report back the list of instructions generated by the lowest non-physical level.

## Well-formness

A quantum program is said to be well formed if for every block used in the program it maintains the block's life-cycle.

> _Theorem:_ a quantum program remains well-formed after getting encoded through a valid quantum stack.

# Evaluating quantum programs:

A stack evaluates a list of instructions and report their measurements by recursively evaluating them on each layer as follows:

1. It identifies all prepare instructions and call `allocate` on the current layer with the correspond block_ids.
2. It calls evaluate on the current layer.
3. If evaluate returns a gadget, it evaluates the gadget as follows:
   - It creates a new stack by removing the top layer from this stack
   - It evaluates the gadget's list of instructions with the new stack
   - It invokes the gadget's continuation it with the outcome of the previous evaluation
   - It keeps evaluating the resulting gadget with the same layer until no more gadgets are returned
4. It identies all measure instructions, and calls `measure` on the current layer with the correspond block_ids.
5. Returns the outcomes from `measure`

```python
def eval_kernel(kernel, stack):
  layer = stack.layers[0]

  if kernel.blocks:
    layer.allocate(kernel.blocks)

  for gadget in layer.eval(instructions):
    eval_gadget(gadget, stack.layers[1:])

  if kernel.blocks:
    return layer.measure(kernel.blocks)
  else:
    return None


def eval_gadget(gadget, stack):
  if gadget is None :
    return
  else:
    outcomes = eval_kernel(gadget.kernel, stack)
    cont_gadget = gadget.continuation(outcomes)
    eval_gadget(cont_gadget, stack)
```
